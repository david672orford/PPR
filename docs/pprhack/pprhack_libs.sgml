<Sect2>
<Title>The PPR Library</Title>

<Para>
The PPR components use a library of common code.  Persons attempting to
extend PPR by adding additional programs are encouraged to make use of the
functions in this library.  This library is contained in a file <Filename>libppr.a</Filename>
which is created in the top level source directory.  Its source code is found
in the <Filename class="Directory">libppr/</Filename> directory.  The prototypes for PPR library functions are
found in the file <Filename>include/global defines.h</Filename> with a few in
<Filename class="HeaderFile">include/global_structs.h</Filename>.
</Para>

<Sect3>
<Title>daemon()</Title>

<Para>
This function is used by PPR programs which run in the background.  A PPR
daemon process should call this function during initialization.  This function
forks and the parent exits.  It also disassociates the process from the
controling terminal and closes all open file descriptors including stdin,
stdout, and stderr.
</Para>

</Sect3>

<Sect3>
<Title>myalloc(), myfree(), myrealloc(), mystrdup(), and mystrndup()</Title>

<Para>
The normal Unix memory allocation routines return a NULL pointer if they
fail to allocate the requested memory.  Since it is very rare that a Unix
system will refuse to allocate any reasonable amount of memory, programers
often ignore the possiblity of malloc() and friends returning NULL.  Since a
memory allocation failure is highly unlikely, PPR programs treat it as a fatal
error, but, rather than test the return value of malloc() after each call, the
calls are encapsulated in special functions which test the return value and
abort the program if the allocation fails.
</Para>

<Para>
A program calling these functions must provide a function called fatal().
This function should print an error message and exit.  The first argument is
the value to pass to exit(), the second is a printf() style format string for
the error message.  Any remaining arguments are the values specified by the
format string.  The caller should create a global integer variable called
<VarName>lib_memory_fatal</VarName> which contains the value these routines should pass as the
first argument to fatal().
</Para>

<Para>
The function myalloc() takes two arguments.  The first is the number of items
to allocate, the second is the size of each in bytes.  This function will return
a void pointer to the allocated memory.  The memory is not initialized.
</Para>

<Para>
The function myfree() is used to free any memory allocated by the other
functions.
</Para>

<Para>
The function myrealloc() changes the size of a memory block.  The
first argument is a pointer to the old block, the second is the desired new
number of members, the third argument is the size of each member in bytes.  This
function returns a pointer to a resized block, possibly at a different
location.
</Para>

<Para>
The function mystrdup() takes a string pointer as its sole argument
and returns a pointer to a new copy of the string.
</Para>

<Para>
The function mystrndup() takes a string pointer and a maximum length as its
arguments.  It returns a pointer to a new string containing a copy of the
string truncated to the maximum length.
</Para>

</Sect3>

<Sect3>
<Title>ppr_sscanf()</Title>

<Para>
This function is similiar to sscanf().  It implements the following formats:
</Para>

<VariableList>

<VarListEntry>
<Term>%d</Term>
<ListItem>
<Para>
read an int.  The argument should be a pointer to an int.
</Para>
</listitem>
</VarListEntry>

<VarListEntry>
<Term>%ld</Term>
<ListItem>
<Para>
read a long int.  The argument should be a pointer to a long
int.
</Para>
</listitem>
</VarListEntry>

<VarListEntry>
<Term>%hd</Term>
<ListItem>
<Para>
read a short int.  The argument should be a pointer to a short
int.
</Para>
</listitem>
</VarListEntry>

<VarListEntry>
<Term>%s</Term>
<ListItem>
<Para>
read characters up to the next whitespace.  The argument should
be a pointer to a char array with enough space to hold the string and the
terminating NULL.  To prevent overruns, the size of the array may be specified
by a decimal number between the <Literal>%</Literal> and the <Literal>s</Literal> 
or by a <Literal>#</Literal>.
If the length of the array is specified with a <Literal>#</Literal> then the actuall
length is read from ppr_sscanf()'s next argument (the one before the pointer to
the char array).
</Para>
</listitem>
</VarListEntry>

<VarListEntry>
<Term>%S</Term>
<ListItem>
<Para>
read characters up to the next whitespace, allocate memory, and
store them in the allocated memory.  The argument should be a pointer to a char
pointer which will be set to the address of the allocated memory.
</Para>
</listitem>
</VarListEntry>

<VarListEntry>
<Term>%z</Term>
<ListItem>
<Para>
read characters up to the end of the string.  The argument
should be a char array.  To prevent overruns, the size of the char array may be
specified in the same manner as for the %s format.
</Para>
</listitem>
</VarListEntry>

<VarListEntry>
<Term>%Z</Term>
<ListItem>
<Para>
read characters up to the end of the string, allocate storeage
for them, and copy them into that storage.  The argument should be a pointer to
a pointer to a char array.
</Para>
</listitem>
</VarListEntry>

</VariableList>

</Sect3>

<Sect3>
<Title>ppr_get_nodename()</Title>

<Para>
This function should return the node name which other nodes will use when
sending jobs to this node.  In the current implementation this is the system
name truncated before the first period (if present) and furthur truncated to 16
characters.
</Para>

</Sect3>

<Sect3>
<Title>fname_sprintf()</Title>

<Para>
This is a special version of sprintf().  It will never write more than
MAX_PATH characters.  It only understands %s and %d.  On
MS-Windows systems it will convert <Literal>:</Literal> to
<Literal>!</Literal> because they are confused
by colons in filenames.
</Para>

</Sect3>

</Sect2>

</Sect1>
