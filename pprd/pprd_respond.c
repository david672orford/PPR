/*
** mouse:~ppr/src/pprd/pprd_respond.c
** Copyright 1995--2001, Trinity College Computing Center.
** Written by David Chappell.
**
** Permission to use, copy, modify, and distribute this software and its
** documentation for any purpose and without fee is hereby granted, provided
** that the above copyright notice appear in all copies and that both that
** copyright notice and this permission notice appear in supporting
** documentation.  This software and documentation are provided "as is"
** without express or implied warranty.
**
** Last modified 10 September 2001.
*/

/*
**
** This module contains routines to send users messages telling them what
** finally happened to their jobs.  Users are informed of job completion,
** job deletion, and other interesting events by running programs in the
** responders directory.
**
** These routines may appear to be similiar to those in ppr_respond.c and you
** may well wonder why the same source module us not used for both.  The
** reason is that none of the actual response message occur in both.
**
** The function respond() is most often called from within a signal handler.
** This means that none of the code in this module should call routines
** which are not reentrant.  That condition is not currently met.
*/

#include "before_system.h"
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#ifdef INTERNATIONAL
#include <libintl.h>
#endif
#include "gu.h"
#include "global_defines.h"

#include "global_structs.h"
#include "pprd.h"
#include "respond.h"
#include "./pprd.auto_h"

#define MAX_RINFO_FOR 79	/* max length of "For: " line argument to use in response */
#define MAX_RINFO_TITLE 79	/* max length of "Title: " line argument to use in response */
#define MAX_RINFO_REASON 63	/* reason job was arrested */

struct RINFO
    {
    const char *destnode;
    const char *destname;
    int id;
    int subid;
    const char *homenode;

    int response_code;
    int prnid;
    const char *prnname;

    /* Responder program, address and options. */
    char response_method[MAX_RESPONSE_METHOD + 1];
    char response_address[MAX_RESPONSE_ADDRESS + 1];
    char responder_options[MAX_RESPONDER_OPTIONS + 1];

    char ForLine[MAX_RINFO_FOR + 1];	/* person for whom we are doing this */
    char Title[MAX_RINFO_TITLE + 1];

    long Time;
    char Reason[MAX_RINFO_REASON + 1];

    int pages_printed;
    struct COMPUTED_CHARGE charge;	/* the amount of money to charge */
    } ;

/*
** Read enough information from the queue file to send the response to the
** right place with the right parameters.
**
** This routine is passed a partially filled in RINFO structure, it must fill
** in the rest.
**
** Since this routine operates on files generated by ppr and not by hand,
** it will assume that one space follows the colon that separates the keyword
** from its value.  We also assume that there is no trailing space to be
** removed.
*/
static void respond_get_info(struct RINFO *rinfo)
    {
    const char function[] = "respond_get_info";
    char fname[MAX_PPR_PATH];		/* room to build name of queue file */
    FILE *f;				/* for open queue file */
    char *line = NULL;			/* line from queue file */
    int line_space_available = 80;

    int pages = -1;
    int pagelist_pages = -1;
    int copies = -1;
    int N = 1;
    int pagefactor = 1;
    int sigsheets = 0;
    int sigpart = SIG_BOTH;
    gu_boolean charge_to = FALSE;

    DODEBUG_RESPOND(("%s(rinfo = {destname=\"%s\", id=%d, subid=%d, homenode=\"%s\"})", function, rinfo->destname, rinfo->id, rinfo->subid, rinfo->homenode));

    /* Be paranoid, fill in default values. */
    strcpy(rinfo->response_method, "none");
    rinfo->response_address[0] = '\0';
    rinfo->responder_options[0] = '\0';
    rinfo->ForLine[0] = '\0';
    rinfo->Title[0] = '\0';
    rinfo->Time = 0;
    rinfo->Reason[0] = '\0';

    ppr_fnamef(fname, "%s/%s:%s-%d.%d(%s)", QUEUEDIR, rinfo->destnode, rinfo->destname, rinfo->id, rinfo->subid, rinfo->homenode);
    if(!(f = fopen(fname, "r")))
	{
	error("%s(): can't open \"%s\", errno=%d (%s)", function, fname, errno, gu_strerror(errno));
	return;
	}

    while((line = gu_getline(line, &line_space_available, f)))
	{
	if(gu_sscanf(line, "Response: %#s %#s %#z",
		MAX_RESPONSE_METHOD, rinfo->response_method,
		MAX_RESPONSE_ADDRESS, rinfo->response_address,
		MAX_RESPONDER_OPTIONS, rinfo->responder_options) >= 2)
	    {}
	else if(gu_sscanf(line, "For: %#z", MAX_RINFO_FOR, &rinfo->ForLine) == 1)
	    {}
	else if(gu_sscanf(line, "Title: %#z", MAX_RINFO_TITLE, rinfo->Title) == 1)
	    {}
	else if(gu_sscanf(line, "Time: %ld", &rinfo->Time) == 1)
	    {}
	else if(strncmp(line, "Reason: (", 9) == 0)
	    {
	    if(rinfo->response_code == RESP_ARRESTED
	    	    || rinfo->response_code == RESP_STRANDED_PRINTER_INCAPABLE
	    	    || rinfo->response_code == RESP_STRANDED_GROUP_INCAPABLE)
		{
		int len = strcspn(&line[9], ")");
		if(len > MAX_RINFO_REASON)
		    len = MAX_RINFO_REASON;
		strncpy(rinfo->Reason, &line[9], len);
		rinfo->Reason[len] = '\0';
		}
    	    }
	else if(sscanf(line, "Attr: %*s %*s %d %*s %*s %*s %*s %*s %d", &pages, &pagefactor) == 9)
	    {}
	else if(sscanf(line, "Opts: %*s %d", &copies) == 2)
	    {}
	else if(sscanf(line, "N-Up: %d %*s %d %d", &N, &sigsheets, &sigpart) == 4)
	    {}
    	else if(strncmp(line, "Charge-To:", 10) == 0)
    	    charge_to = TRUE;
	else if(gu_sscanf(line, "PageList: %d", &pagelist_pages) == 1)
	    {}
	} /* while(gu_getline()) */

    fclose(f);

    /*
    ** If a pagelist was used, use the page count from the pagelist.
    */
    if(pagelist_pages != -1)
    	pages = pagelist_pages;

    /*
    ** Compute the number of pages which will have been printed.  This
    ** is sort of an after the fact prediction.  *** This code needs
    ** work! ***
    */
    if(pages >= 0)
    	{
	rinfo->pages_printed = (pages + N - 1) / N;
	if(copies >= 0)
	    rinfo->pages_printed *= copies;
	}
    else
	{
	rinfo->pages_printed = -1;
	}

    /*
    ** Compute how much the user has been charged if this job
    ** was printed.  If the responder message is to the effect
    ** that the job was submitted to an unknown destination
    ** then prnid will be -1 and we can't compute the charge.
    */
    if(rinfo->response_code == RESP_FINISHED && rinfo->prnid >= 0)
	{
	compute_charge(&rinfo->charge,
	    	printers[rinfo->prnid].charge_per_duplex,
		printers[rinfo->prnid].charge_per_simplex, pages, N, pagefactor,
		sigsheets, sigpart, copies);
	}
    else
    	{
    	rinfo->charge.total = 0;
    	}
    } /* end of respond_get_info() */

/*
** Build a message in final_str, basing it upon the code "response" and inserting
** particuliar information from the other arguments.
*/
static void respond_build_message(char *response_str, size_t len, struct RINFO *rinfo)
    {
    switch(rinfo->response_code)
	{
	case RESP_FINISHED:
	    snprintf(response_str, len,
	    _("Your print job \"%s\" has been printed on \"%s\"."),
	    remote_jobid(rinfo->destnode,rinfo->destname,rinfo->id,rinfo->subid,rinfo->homenode), rinfo->prnname);
	    break;
	case RESP_ARRESTED:
	    snprintf(response_str, len,
	    _("Your print job \"%s\" was arrested after an attempt\n"
	    "to print it on \"%s\" resulted in a job error."),
	    remote_jobid(rinfo->destnode,rinfo->destname,rinfo->id,rinfo->subid,rinfo->homenode), rinfo->prnname);
	    break;
	case RESP_CANCELED:
	    snprintf(response_str, len,
	    _("Your print job \"%s\" has been canceled."),
	    remote_jobid(rinfo->destnode,rinfo->destname,rinfo->id,rinfo->subid,rinfo->homenode));
	    break;
	case RESP_CANCELED_PRINTING:
	    snprintf(response_str, len,
	    _("Your print job \"%s\" was canceled while printing on \"%s\"."),
	    remote_jobid(rinfo->destnode,rinfo->destname,rinfo->id,rinfo->subid,rinfo->homenode), rinfo->prnname);
	    break;
	case RESP_CANCELED_BADDEST:
	    snprintf(response_str, len,
	    _("Your print job \"%s\" was canceled because\n"
	    "\"%s\" is not a known destination."),
	    remote_jobid(rinfo->destnode,rinfo->destname,rinfo->id,rinfo->subid,rinfo->homenode), rinfo->destname);
	    break;
	case RESP_CANCELED_REJECTING:
	    snprintf(response_str, len,
	    _("Your print job \"%s\" was canceled because\n"
	    "the destination \"%s\" is not acceping requests."),
	    remote_jobid(rinfo->destnode,rinfo->destname,rinfo->id,rinfo->subid,rinfo->homenode), rinfo->destname);
	    break;
	case RESP_STRANDED_PRINTER_INCAPABLE:
	    snprintf(response_str, len,
	    _("Your print job \"%s\" is stranded because\n"
	    "the printer \"%s\" is incapable of printing it."),
	    remote_jobid(rinfo->destnode,rinfo->destname,rinfo->id,rinfo->subid,rinfo->homenode), rinfo->prnname);
	    break;
	case RESP_STRANDED_GROUP_INCAPABLE:
	    snprintf(response_str, len,
	    _("Your print job \"%s\" is stranded because no\n"
	    "member of the group \"%s\" is capable of printing it."),
	    remote_jobid(rinfo->destnode,rinfo->destname,rinfo->id,rinfo->subid,rinfo->homenode), rinfo->destname);
	    break;
	default:
	    snprintf(response_str, len,
	    	_("Undefined response code %d for your job \"%s\"."),
	    	rinfo->response_code, remote_jobid(rinfo->destnode,rinfo->destname,rinfo->id,rinfo->subid,rinfo->homenode));
	}
    } /* end of respond_build_message() */

/*
** Build a second message string which the responder can use
** if there is enough room.
*/
static void respond_build_message2(char *s, size_t line, struct RINFO *rinfo)
    {
    s[0] = '\0';
    } /* end of build_response_message2() */

/*
** Fork() and exec() a responder.
*/
static void respond_launch(struct RINFO *rinfo, const char *response_message, const char *response_message2)
    {
    const char function[] = "respond_launch";
    pid_t pid;					/* Process id of responder */

    if((pid = fork()) == -1)			/* if error, */
	{
	error("can't fork() in respond_launch()");
	}
    else if(pid == 0)				/* if child, */
	{
	int fd;					/* fd opening job log and pprd log */
	char fname[MAX_PPR_PATH];	    	    	/* scratch space for file names */

	char code_in_ascii[3];
	char time_in_ascii[16];
	char numpages_in_ascii[7];
	char queue_id[100];	    	    	/* Actually too big (59 characters used). */

    	/* Build several parameter strings. */
	snprintf(code_in_ascii, sizeof(code_in_ascii), "%d", rinfo->response_code);
	snprintf(time_in_ascii, sizeof(time_in_ascii), "%ld", rinfo->Time);
	snprintf(queue_id, sizeof(queue_id), "%s %s %d %d %s", rinfo->destnode, rinfo->destname, rinfo->id, rinfo->subid, rinfo->homenode);

	/* Build the number of pages as a string. */
	if(rinfo->response_code == RESP_FINISHED && rinfo->pages_printed >= 0 && rinfo->pages_printed < 1000000)	/* 1,000,000 */
	    snprintf(numpages_in_ascii, sizeof(numpages_in_ascii), "%d", rinfo->pages_printed);
	else
	    strcpy(numpages_in_ascii, "?");

	/*
	** Open the log file, or, if there is none, open /dev/null.
	** The idea is that the responder should find the log file
	** on stdin.
	*/
	ppr_fnamef(fname, "%s/%s:%s-%d.%d(%s)-log", DATADIR, rinfo->destnode, rinfo->destname, rinfo->id, rinfo->subid, rinfo->homenode);
	if((fd = open(fname, O_RDONLY)) < 0)
	    {
	    if((fd = open("/dev/null", O_RDONLY)) < 0)
	    	fatal(1, "%s(): child: can't open \"/dev/null\", errno=%d (%s)", function, errno, gu_strerror(errno) );
	    }

	/* If the handle we got was not stdin, make it stdin. */
	if(fd != 0)
	    {
	    dup2(fd, 0);
	    close(fd);
	    }

	/* Connect stdout and stderr to the pprd log file. */
	if((fd = open(PPRD_LOGFILE, O_WRONLY | O_CREAT | O_APPEND, UNIX_644)) < 0)
	    fatal(1, "%s(): child: can't open \"%s\", errno=%d (%s)", function, PPRD_LOGFILE, errno, gu_strerror(errno));
	if(fd != 1) dup2(fd, 1);
	if(fd != 2) dup2(fd, 2);
	if(fd > 2) close(fd);

	/* Build path to responder. */
	ppr_fnamef(fname, "%s/%s", RESPONDERDIR, rinfo->response_method);

	/* Replace this child program with the responder. */
	execl(fname, rinfo->response_method,
		rinfo->ForLine,			/* name of person job printed for */
		rinfo->response_address,	/* address to send message to */
		response_message,		/* suggested message text */
		response_message2,
		rinfo->responder_options,   	/* user specified responder options */
		code_in_ascii,			/* code number of message type */
		queue_id,		    	/* full queue id of job */
		rinfo->prnname,			/* name of printer or text of error message */
		rinfo->Title,			/* title of job */
		time_in_ascii,			/* time job was submitted */
		rinfo->Reason,			/* reason last arrested */
		numpages_in_ascii,		/* number of pages printed */
		rinfo->charge.total != 0 ? money(rinfo->charge.total) : "",
		(char*)NULL);

	/* Catch execl() failure: */
	DODEBUG_RESPOND(("%s(): execl() failed, errno=%d (%s)", function, errno, gu_strerror(errno)));
	_exit(242);
	}
    } /* end of respond_launch() */

/*
** This is called whenever a responder exits.
*/
void responder_child_hook(pid_t pid, int wstat)
    {
    DODEBUG_RESPOND(("(respond process?)"));

    if(WIFSIGNALED(wstat))
        error("Process %ld was killed by signal %d (%s)", (long)pid, WTERMSIG(wstat), gu_strsignal(WTERMSIG(wstat)) );
    else if( WIFEXITED(wstat) && WEXITSTATUS(wstat) != 0 )
        error("Process %ld exited with error code %d", (long)pid, WEXITSTATUS(wstat) );

    if(WCOREDUMP(wstat))
        error("Process %ld dumped core", (long)pid);
    } /* end of responder_child_hook() */

/*
** Send a response to the user by means of the designated response method.
**
** This routine is sometimes called directly, at other times it is called
** by the wrapper routine respond().
**
** If there is no prnid, then use -1.
*/
void respond2(const char *destnode, const char *destname, int id, int subid, const char *homenode, const char *prnname, int prnid, int response_code)
    {
    FUNCTION4DEBUG("respond2")
    char response_message[256];		/* too big (none of the messages top 170 characters) */
    char response_message2[1024];
    struct RINFO rinfo;

    DODEBUG_RESPOND(("%s(destnode=\"%s\", destname=\"%s\", id=%d, subid=%d, homenode=\"%s\", prnname=\"%s\", prnid=%d, response_code=%d)", function, destnode, destname, id, subid, homenode, prnname, prnid, response_code));

    /* Fill in some of rinfo, respond_get_info() will fill in the rest. */
    rinfo.destnode = destnode;
    rinfo.destname = destname;
    rinfo.id = id;
    rinfo.subid = subid;
    rinfo.homenode = homenode;
    rinfo.response_code = response_code;
    rinfo.prnname = prnname;
    rinfo.prnid = prnid;

    /* Read the responding information from the queue file. */
    respond_get_info(&rinfo);

    /* If no response is wanted, then we are done. */
    if(strcmp(rinfo.response_method, "none") == 0)
	return;

    DODEBUG_RESPOND(("%s(): method=\"%s\", address=\"%s\" options=\"%s\"", function, rinfo.response_method, rinfo.response_address, rinfo.responder_options));

    /* Construct the first message string and possibly re-wrap it. */
    respond_build_message(response_message, sizeof(response_message), &rinfo);
    gu_wordwrap(response_message, get_responder_width(rinfo.response_method));

    /* Do the same for the second message string: */
    respond_build_message2(response_message2, sizeof(response_message2), &rinfo);
    gu_wordwrap(response_message2, get_responder_width(rinfo.response_method));

    /* Launch the responder. */
    respond_launch(&rinfo, response_message, response_message2);
    } /* end of respond2() */

/*
** This is the outer routine.  It takes a destination and a node id number and
** converts them to names before calling respond2() which does the real work.
**
** Sometimes the prnid will be -1, but destid_to_name() can deal with that.
*/
void respond(int destnode_id, int destid, int id, int subid, int homenode_id, int prnid, int response)
    {
    DODEBUG_RESPOND(("respond(destnode_id=%d, destid=%d, id=%d, subid=%d, homenode_id=%d, prnid=%d, response=%d)", destnode_id, destid, id, subid, homenode_id, prnid, response));
    respond2(nodeid_to_name(destnode_id), destid_to_name(destnode_id, destid), id, subid, nodeid_to_name(homenode_id), destid_to_name(destnode_id, prnid), prnid, response);
    }

/* end of file */
