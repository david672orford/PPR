void alert_printer_failed(char *prn, int frequency, char *method, char *address, int n);
void alert_printer_working(char *prn, int frequency, char *method, char *address, int n);
void child_unblock_all(void);
void child_stdin_stdout_stderr(const char input_file[], const char output_file[]);
void lock(void);
void unlock(void);
void reapchild(int signum);
void tick(int sig);
int main(int argc, char *argv[]);
const char *destid_local_to_name(int destid);
int destid_local_by_printer(const char name[]);
int destid_local_by_name(const char name[]);
int destid_local_by_name_reversed(char *name);
int destid_local_is_group(int id);
int destid_local_get_member_offset(int destid, int prnid);
int destid_printer_bit(int destid, int prnid);
int destid_local_to_gindex(int destid);
int destid_local_by_gindex(int gindex);
int destid_assign(int destnode_id, const char name[]);
void destid_free(int destnode_id, int destid);
const char *destid_to_name(int destnode_id, int destid);
int destid_by_name(int destnode_id, const char name[]);
gu_boolean destid_accepting(int destnode_id, int destid);
void load_printers(void);
void new_printer_config(char *printer);
void load_groups(void);
void new_group_config(char *group);
void initialize_queue(void);
void fatal(int exitval, const char message[], ... );
void error(const char message[], ...);
void debug(const char message[], ...);
void gu_throw(int exception_type, const char exception_function[], const char format[], ...);
int open_fifo(void);
void install_signal_handlers(void);
void create_lock_file(void);
void rename_old_log_file(void);
void root_create_directories(uid_t euid, gid_t egid);
void create_work_directories(void);
void adjust_ids(void);
void parse_command_line(int argc, char *argv[], int *option_foreground);
void media_mounted_save(int prnid);
void media_mounted_recover(int prnid);
const char *get_media_name(int mediaid);
int get_media_id(char *medianame);
const char *get_bin_name(int binid);
int get_bin_id(char *nbinname);
void media_startstop_update_waitreason(int prnid);
void media_update_notnow(int prnid);
void media_set_notnow_for_job(struct QEntry *nj, gu_boolean inqueue);
int nodeid_assign(const char nodename[]);
void nodeid_free(int nodeid);
int nodeid_by_name(const char name[]);
const char *nodeid_to_name(int nodeid);
int nodeid_local(void);
gu_boolean nodeid_is_local_node(int nodeid);
void ppop_dispatch(const char command[]);
int pprdrv_start(int prnid, struct QEntry *job);
gu_boolean pprdrv_child_hook(pid_t pid, int wstat);
void pprdrv_kill(int prnid);
void printer_look_for_work(int prnid);
void printer_try_start_suitable_4_this_job(struct QEntry *job);
void printer_new_status(struct Printer *printer, int newstatus);
void printer_tick(void);
void question_init(void);
void question_job(struct QEntry *job);
gu_boolean question_child_hook(pid_t pid, int wstat);
void question_tick(void);
void queue_dequeue_job(int destnode_id, int destid, int id, int subid, int homenode_id);
struct QEntry *queue_p_job_new_status(struct QEntry *job, int newstat);
struct QEntry *queue_job_new_status(int id, int subid, int homenode_id, int newstat);
int queue_read_queuefile(const char qfname[], struct QEntry *newentry);
void queue_accept_queuefile(const char qfname[], gu_boolean job_is_new);
void queue_new_job(char *command);
void ppad_remind(void);
void remote_job(struct QEntry *qentry);
gu_boolean remote_child_hook(pid_t pid, int wstat);
void remote_tick(void);
void responder_child_hook(pid_t pid, int wstat);
void respond2(const char *destnode, const char *destname, int id, int subid, const char *homenode, const char *prnname, int prnid, int response_code);
void respond(int destnode_id, int destid, int id, int subid, int homenode_id, int prnid, int response);
void state_update(const char *string, ... );
extern struct QEntry *queue;
extern int queue_size;
extern int queue_entries ;
extern struct Printer *printers;
extern int printer_count ;
extern struct Group *groups;
extern int group_count ;
extern int upgrade_countdown ;
extern int active_printers ;
extern int starving_printers ;
extern int lock_level ;
