/*
** mouse:~ppr/src/pprd/ppr-respond.c
** Copyright 1995--2004, Trinity College Computing Center.
** Written by David Chappell.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are met:
**
** * Redistributions of source code must retain the above copyright notice,
** this list of conditions and the following disclaimer.
**
** * Redistributions in binary form must reproduce the above copyright
** notice, this list of conditions and the following disclaimer in the
** documentation and/or other materials provided with the distribution.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
**
** Last modified 12 February 2004.
*/

/*
** This program is called by ppr and pprd when they want to respond to the 
** user.  It receives the job id (or if there isn't one yet, just the 
** destination id), the responder code number, and an additional parameter
** (the meaning of which depends on the code number).  If there is a queue
** file, it is opened and information is read from it.  A well formed
** message is generated and then the responder program is run to transmit
** the message to the user.
**
** Note that the calling conventions of this program will change as PPR
** changes.  One goal of this program is to hide those calling convention
** changes by keeping the interface to the responder scripts as unchanging
** as possible.
**
** Note though that I (David Chappell) intent to completely change that
** interface before declaring a new stable interface.  This will be done
** because the current interface to the responder scripts doesn't allow
** for the adding of new parameters except by adding new command line
** parameters at fixed positions.  This is simple but error prone.  It will
** be replaced with a system of named parameters.
*/

#include "config.h"
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#ifdef INTERNATIONAL
#include <locale.h>
#include <libintl.h>
#endif
#include "gu.h"
#include "global_defines.h"
#include "global_structs.h"
#include "pprd.h"
#include "respond.h"

const char myname[] = "ppr-respond";

struct RINFO
	{
	char *jobname;
	int response_code;
	char *extra;

	char *lc_messages;

	char *responder;
	char *responder_address;
	char *responder_options;

	char *ForLine;						/* person for whom we are doing this */
	char *Title;

	long Time;
	char *Reason;

	int pages_printed;
	struct COMPUTED_CHARGE charge;		/* the amount of money to charge */
	} ;

/*
** Read enough information from the queue file to send the response to the
** right place with the right parameters.
**
** This routine is passed a partially filled in RINFO structure, it must fill
** in the rest.
**
** Since this routine operates on files generated by ppr and not by hand,
** it will assume that one space follows the colon that separates the keyword
** from its value.  We also assume that there is no trailing space to be
** removed.
*/
static int respond_get_info(struct RINFO *rinfo, int qffd, int charge_per_duplex, int charge_per_simplex)
	{
	const char function[] = "respond_get_info";
	FILE *f;							/* for open queue file */
	char *line = NULL;					/* line from queue file */
	int line_space_available = 80;

	int pages = -1;
	int pagelist_pages = -1;
	int copies = -1;
	int N = 1;
	int pagefactor = 1;
	int sigsheets = 0;
	int sigpart = SIG_BOTH;
	gu_boolean charge_to = FALSE;

	if(!(f = fdopen(qffd, "r")))
		{
		fprintf(stderr, "%s(): fdopen(%d, \"r\") failed, errno=%d (%s)\n", function, qffd, errno, gu_strerror(errno));
		return -1;
		}

	while((line = gu_getline(line, &line_space_available, f)))
		{
		if(gu_sscanf(line, "Response: %S %S %Z",
				&rinfo->responder,
				&rinfo->responder_address,
				&rinfo->responder_options) >= 2)
			{}
		else if(gu_sscanf(line, "For: %Z", &rinfo->ForLine) == 1)
			{}
		else if(gu_sscanf(line, "Title: %Z", &rinfo->Title) == 1)
			{}
		else if(gu_sscanf(line, "Time: %ld", &rinfo->Time) == 1)
			{}
		else if(strncmp(line, "Reason: (", 9) == 0)
			{
			if(rinfo->response_code == RESP_ARRESTED
					|| rinfo->response_code == RESP_STRANDED_PRINTER_INCAPABLE
					|| rinfo->response_code == RESP_STRANDED_GROUP_INCAPABLE)
				{
				rinfo->Reason = line + 9;
				rinfo->Reason = gu_strndup(rinfo->Reason, strcspn(rinfo->Reason, ")"));
				}
			}
		else if(sscanf(line, "Attr-Pages: %d %*d %d", &pages, &pagefactor) == 3)
			{}
		else if(sscanf(line, "Opts: %*s %d", &copies) == 2)
			{}
		else if(sscanf(line, "N-Up: %d %*s %d %d", &N, &sigsheets, &sigpart) == 4)
			{}
		else if(strncmp(line, "Charge-To:", 10) == 0)
			charge_to = TRUE;
		else if(gu_sscanf(line, "PageList: %d", &pagelist_pages) == 1)
			{}
		else if(gu_sscanf(line, "LC_ALL: %S", &rinfo->lc_messages) == 1)
			{}
		} /* while(gu_getline()) */

	fclose(f);

	/*
	** If a pagelist was used, use the page count from the pagelist.
	*/
	if(pagelist_pages != -1)
		pages = pagelist_pages;

	/*
	** Compute the number of pages which will have been printed.  This
	** is sort of an after the fact prediction.	 *** This code needs
	** work! ***
	*/
	if(pages >= 0)
		{
		rinfo->pages_printed = (pages + N - 1) / N;
		if(copies >= 0)
			rinfo->pages_printed *= copies;
		}
	else
		{
		rinfo->pages_printed = -1;
		}

	/*
	** Compute how much the user has been charged if this job
	** was printed.
	*/
	if(rinfo->response_code == RESP_FINISHED)
		{
		compute_charge(&rinfo->charge,
				charge_per_duplex, charge_per_simplex,
				pages, N, pagefactor, sigsheets, sigpart, copies);
		}
	else
		{
		rinfo->charge.total = 0;
		}

	return 0;
	} /* end of respond_get_info() */

/*
** Build a message in final_str, basing it upon the code "response" and inserting
** particuliar information from the other arguments.
*/
static void respond_build_message(char *response_str, size_t space_available, struct RINFO *rinfo)
	{
	switch(rinfo->response_code)
		{
		case RESP_FINISHED:
			snprintf(response_str, space_available,
				_("Your print job \"%s\" has been printed on \"%s\"."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_ARRESTED:
			snprintf(response_str, space_available,
				_("Your print job \"%s\" was arrested after an attempt\n"
				"to print it on \"%s\" resulted in a job error."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_CANCELED:
			snprintf(response_str, space_available,
				_("Your print job \"%s\" has been canceled."),
				rinfo->jobname);
			break;

		case RESP_CANCELED_PRINTING:
			snprintf(response_str, space_available,
				_("Your print job \"%s\" was canceled while printing on \"%s\"."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_CANCELED_BADDEST:
			snprintf(response_str, space_available,
				_("Your print job \"%s\" was canceled because\n"
				"\"%s\" is not a known destination."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_CANCELED_REJECTING:
			snprintf(response_str, space_available,
				_("Your print job \"%s\" was canceled because\n"
				"the destination \"%s\" is not acceping requests."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_STRANDED_PRINTER_INCAPABLE:
			snprintf(response_str, space_available,
				_("Your print job \"%s\" is stranded because\n"
				"the printer \"%s\" is incapable of printing it."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_STRANDED_GROUP_INCAPABLE:
			snprintf(response_str, space_available,
				_("Your print job \"%s\" is stranded because no\n"
				"member of the group \"%s\" is capable of printing it."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_CANCELED_NOCHARGEACCT:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" was rejected because\n"
				"\"%s\" does not have a charge account."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_CANCELED_BADAUTH:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" was rejected because\n"
				"you did not enter %s's authorization code."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_CANCELED_OVERDRAWN:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" was rejected because\n"
				"your account is overdrawn."),
				rinfo->jobname);
			break;

		case RESP_CANCELED_NONCONFORMING:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" was rejected because\n"
				"it does not contain DSC page division information."),
				rinfo->jobname);
			break;

		case RESP_NOFILTER:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" has been rejected because no filter\n"
				"is available which can convert %s to PostScript."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_FATAL:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" has been rejected by PPR because of a\n"
				"fatal error: %s."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_NOSPOOLER:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" has been lost because PPRD is not running."),
				rinfo->jobname);
			break;

		case RESP_BADMEDIA:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" has been rejected because it requires\n"
				"a size and type of medium (paper) which is not available."),
				rinfo->jobname);
			break;

		case RESP_BADPJLLANG:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" has been rejected because the\n"
				"PJL header requests an unrecognized printer language \"%s\"."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_FATAL_SYNTAX:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" has been rejected because\n"
				"the ppr command line contains an error:\n"
				"\n"
				"%s."),
				rinfo->jobname, rinfo->extra);
			break;

		case RESP_CANCELED_NOPAGES:
			snprintf(response_str, space_available,
				_("Your new print job for \"%s\" has been rejected because\n"
				"you requested printing of only selected pages but the pages\n"
				"are not marked by DSC comments."),
				rinfo->jobname);
			break;

		case RESP_CANCELED_ACL:
			snprintf(response_str, space_available,
				_("Your print job for \"%s\" has been rejected because the\n"
				"PPR access control lists do not grant \"%s\" access to\n"
				"that destination."),
				rinfo->jobname, rinfo->extra);
			break;

		default:
			snprintf(response_str, space_available,
				_("Undefined response code %d for your job \"%s\"."),
				rinfo->response_code, rinfo->jobname);
			break;
		}
	} /* end of respond_build_message() */

/*
** The command line interface of this program is not documented.  It will
** quite likely change with each version of PPR.  Different parameters
** are expected based upon which program invokes it (as indicated by
** argv[1]).
*/
int main(int argc, char *argv[])
	{
	struct RINFO rinfo;
	char response_message[256];
	char responder_fname[MAX_PPR_PATH];
	char time_in_ascii[16];
	char numpages_in_ascii[16];

	/* all formats have these parameters in common */
	rinfo.jobname = argv[2];
	rinfo.response_code = atoi(argv[3]);
	rinfo.extra = argv[4];

	/* clear these in case we don't get them */
	rinfo.responder = NULL;
	rinfo.responder_address = NULL;
	rinfo.responder_options = "";
	rinfo.lc_messages = NULL;
	rinfo.ForLine = "";
	rinfo.Title = "";
	rinfo.Time = 0;
	rinfo.Reason = "";
	rinfo.pages_printed = -1;
	rinfo.charge.total = 0;

	/* pprd provides 2 additional parameters and a queue file on fd 3 */
	if(strcmp(argv[1], "pprd") == 0)
		{
		int charge_per_duplex, charge_per_simplex;
		charge_per_duplex = atoi(argv[5]);
		charge_per_simplex = atoi(argv[6]);
		if(respond_get_info(&rinfo, 3, charge_per_duplex, charge_per_simplex) == -1)
			return 1;
		}

	/* ppr provides no queue file but it makes up for it in parameters */
	else if(strcmp(argv[1], "ppr") == 0)
		{
		rinfo.responder = argv[5];
		rinfo.responder_address = argv[6];
		rinfo.responder_options = argv[7];
		rinfo.ForLine = argv[8];
		rinfo.Title = argv[9];
		rinfo.lc_messages = argv[10];
		}

	else if(strcmp(argv[1], "pprdrv") == 0)
		{
		}

	else
		{
		fprintf(stderr, "%s: unrecognized first argument: %s\n", myname, argv[1]);
		return 1;
		}

	/* Sanity check */
	if(!rinfo.responder && !rinfo.responder_address)
		{
		fprintf(stderr, "%s: responder name or address missing\n", myname);
		return 1;
		}

	/* If no response is possible, then we are done. */
	if(strcmp(rinfo.responder, "none") == 0)
		return 0;

	/* Initialize international messages library. */
	#ifdef INTERNATIONAL
	setlocale(LC_ALL, rinfo.lc_messages);
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE);
	#endif

	/* Construct the message string. */
	respond_build_message(response_message, sizeof(response_message), &rinfo);

	/* Convert some other stuff to strings. */
	snprintf(time_in_ascii, sizeof(time_in_ascii), "%ld", rinfo.Time);
	snprintf(numpages_in_ascii, sizeof(numpages_in_ascii), "%d", rinfo.pages_printed);

	/* handle the followme meta responder */
	if(strcmp(rinfo.responder, "followme") == 0)
		{
		gu_boolean found = FALSE;
		char fname[MAX_PPR_PATH];
		FILE *f;
		ppr_fnamef(fname, "%s/followme.db/%s", VAR_SPOOL_PPR, rinfo.responder_address);
		if((f = fopen(fname, "r")))
			{
			int line_available = 80;
			char *line = NULL;
			if((line = gu_getline(line, &line_available, f)))
				{
				char *responder, *responder_address, *responder_options;
				if(gu_sscanf(line, "%S %S %Q", &responder, &responder_address, &responder_options) == 3)
					{
					found = TRUE;

					/* Yes, we leak memory here when run by pprd, but it doesn't matter. */

					rinfo.responder = responder;

					rinfo.responder_address = responder_address;

					/* If both the job and followme supply responder options, 
					   we will use the ones from the job followed by those 
					   from followme. */
					if(strlen(responder_options) > 0)			/* if any from followme, */
						{
						if(strlen(rinfo.responder_options) > 0) /* if any from job too, */
							{
							char *p;
							gu_asprintf(&p, "%s %s", responder_options, rinfo.responder_options);
							gu_free(responder_options);
							rinfo.responder_options = p;
							}
						else									/* if just from followme, */
							{
							rinfo.responder_options = responder_options;
							}
						}
					}
				gu_free(line);
				}
			fclose(f);
			}
		if(!found)
			rinfo.responder = "write";
		}

	/* Build path to responder. */
	ppr_fnamef(responder_fname, "%s/%s", RESPONDERDIR, rinfo.responder);

	/* Replace this child program with the responder. */
	execl(responder_fname, rinfo.responder,
				rinfo.ForLine,					/* name of person job printed for */
				rinfo.responder_address,		/* address to send message to */
				response_message,				/* suggested message text */
				"",
				rinfo.responder_options,
				argv[3],						/* code number of message type */
				rinfo.jobname,					/* queue id of job */
				rinfo.extra,					/* name of printer or text of error message */
				rinfo.Title,					/* title of job */
				time_in_ascii,					/* time job was submitted */
				rinfo.Reason,					/* reason last arrested */
				numpages_in_ascii,				/* number of pages printed */
				rinfo.charge.total != 0 ? money(rinfo.charge.total) : "",
				(char*)NULL);

	/* Catch execl() failures. */
	fprintf(stderr, "%s: execl(\"%s\", ...) failed, errno=%d (%s)\n", myname, responder_fname, errno, gu_strerror(errno));
	return 1;
	}

/* end of file */
