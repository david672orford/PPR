#! /usr/bin/perl -wT
#
# mouse:~ppr/src/www/df_img.cgi.perl
# Copyright 1995--2000, Trinity College Computing Center.
# Written by David Chappell.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted, provided
# that the above copyright notice appears in all copies and that both that
# copyright notice and this permission notice appear in supporting
# documentation.  This software and documentation are provided "as is"
# without express or implied warranty.
#
# Last modified 15 June 2000.
#

#
# This CGI script produces the pie chart PNG images which are inline images
# in the HTML document generated by df_html.cgi.  Because the sizes of the
# 3 pie slices are fully encoded in the query string of the URL, these
# images are cachable.
#

use lib "?";
require 'cgi_data.pl';
require 'cgi_time.pl';

# Read the sizes of the 3 pie slices from the query string.
cgi_read_data();
my $used = cgi_data_move('used', -1);
my $available = cgi_data_move('available', -1);
my $reserved = cgi_data_move('reserved', -1);

if(0)
    {
    require Chart::PNGgraph::pie;

    # Create a pie graph object.
    my $graph = new Chart::PNGgraph::pie(200, 150);

    # Set the background colour, make the image transparent,
    # and set the colors for the slices.
    $graph->set(
	'bgclr' => 'white',
	'transparent' => 1,
	'dclrs' => [qw(green yellow red)]
	);

    # Setting this font size causes rendering errors.
    #$graph->set_value_font(GD::gdLargeFont);

    # Assemble the data, namely the 3 slice names and their sizes.
    my $data = [
	[ "${used}% Used", "${available}% Available", "${reserved}% Reserved" ],
	[ $used,           $available,                $reserved ]
	];

    # Generate PNG image data.
    $image = $graph->plot($data);
    }

else
    {
    require Chart::Bars;
    my $graph = Chart::Bars->new(200, 150);
    $graph->set(
	'transparent' => 'true',
	'legend_labels' => ["${used}% Used", "${available}% Available", "${reserved}% Reserved"],
	'graph_border' => 0,
	'text_space' => 0
	);
    $image = $graph->scalar_png([
	[],
	[$used],
	[$available],
	[$reserved]
	]);
    }

# Compute the Unix time of the next midnight.  That will be
# the image expiration time.
my $seconds_per_day = (24 * 60 * 60);
my $now_days = int(time() / $seconds_per_day);
my $expire_time = ($now_days + 1) * $seconds_per_day;

# Emit a CGI header and then the image data.  Note that we
# send a "Content-Length:" header.  This means that persistent
# connexions can stay open even if chunked transfer is not
# supported.
print "Expires: ", cgi_time_format($expire_time), "\n";
print "Content-Length: ", length($image), "\n";
print "Content-Type: image/png\n";
print "\n";
print $image;

exit 0;
